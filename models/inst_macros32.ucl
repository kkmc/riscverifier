// Constants
const bool_to_bv32[boolean]bv32;
// Loads values from byte-sized memory
define loadByte_macro (mem: [bv32]bv8, addr: bv32): bv8 = (mem)[addr];
define loadHalf_macro (mem: [bv32]bv8, addr: bv32): bv16 = (loadByte_macro(mem, (addr + 1bv32)) ++ loadByte_macro(mem, addr));
define loadWord_macro (mem: [bv32]bv8, addr: bv32): bv32 = (loadHalf_macro(mem, (addr + 2bv32)) ++ loadHalf_macro(mem, addr));
//define loadDouble_macro (mem: [bv32]bv8, addr: bv32): bv32 = (loadWord_macro(mem, (addr + 4bv32)) ++ loadWord_macro(mem, addr));
// Memory updates to byte-sized memory
define mem_update_byte(memP: [bv32]bv8, index: bv32, value: bv8): [bv32]bv8 = memP[index -> value];
define mem_update_half(memP: [bv32]bv8, index: bv32, value: bv16): [bv32]bv8 = mem_update_byte(mem_update_byte(memP, index, value[7:0]), index+1bv32, value[15:8]);
define mem_update_word(memP: [bv32]bv8, index: bv32, value: bv32): [bv32]bv8 = mem_update_half(mem_update_half(memP, index, value[15:0]), index+2bv32, value[31:16]);
//define mem_update_double(memP: [bv32]bv8, index: bv32, value: bv32): [bv32]bv8 = mem_update_word(mem_update_word(memP, index, value[31:0]), index+4bv32, value[63:32]);
// Instruction specifications
define amoswap_w_aq_inst(): bv32 = 0bv32;
define amoor_w_inst(): bv32 = 0bv32;
define amoor_w_aq_inst(): bv32 = 0bv32;
define add_inst(rs1: bv32, rs2: bv32): bv32 = (r1 + r2);
define sub_inst(rs1: bv32, rs2: bv32): bv32 = (rs1 - rs2);
// TODO: Check semantics
define mul_inst(rs1: bv32, rs2: bv32): bv32 = (rs1 * rs2);
// FIXME: Implement
define div_inst(rs1: bv32, rs2: bv32): bv32 = 0bv32;    // FIXME
// FIXME: Implement
define rem_inst(rs1: bv32, rs2: bv32): bv32 = 0bv32;    // FIXME
define sll_inst(rs1: bv32, rs2: bv32): bv32 = bv_left_shift((rs2 & 63bv32), rs1);
define slt_inst(rs1: bv32, rs2: bv32): bv32 = bool_to_bv32[true -> 1bv32][false -> 0bv32][(rs1 < rs2)];
define sltu_inst(rs1: bv32, rs2: bv32): bv32 = bool_to_bv32[true -> 1bv32][false -> 0bv32][(rs1 <_u rs2)];
define xor_inst(rs1: bv32, rs2: bv32): bv32 = (rs1 ^ rs2);
define srl_inst(rs1: bv32, rs2: bv32): bv32 = bv_l_right_shift((rs2 & 63bv32), rs1);
define sra_inst(rs1: bv32, rs2: bv32): bv32 = bv_a_right_shift((rs2 & 63bv32), rs1);
define or_inst(rs1: bv32, rs2: bv32): bv32 = (rs1 | rs2);
define and_inst(rs1: bv32, rs2: bv32): bv32 = (rs1 & rs2);
//define addw_inst(rs1: bv32, rs2: bv32): bv32 = bv_sign_extend(32, (rs1 + rs2)[31:0]);
//define subw_inst(rs1: bv32, rs2: bv32): bv32 = bv_sign_extend(32, (rs1 - rs2)[31:0]);
//define sllw_inst(rs1: bv32, rs2: bv32): bv32 = bv_sign_extend(32, bv_left_shift(bv_zero_extend(27, rs2[4:0]), rs1[31:0]));
//define srlw_inst(rs1: bv32, rs2: bv32): bv32 = bv_sign_extend(32, bv_l_right_shift(bv_zero_extend(27, rs2[4:0]), rs1[31:0]));
//define sraw_inst(rs1: bv32, rs2:bv32): bv32 = bv_sign_extend(32, bv_a_right_shift(bv_zero_extend(27, rs2[4:0]), rs1[31:0]));
define jalr_inst(rs1: bv32, imm: bv32): bv32 = (rs1 + imm)[63:1] ++ 0bv1;
define mret_inst(): bv32 = 0bv32;   // FIXME;
define lb_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(56, loadByte_macro(mem, rs1 + imm));
define lh_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(48, loadHalf_macro(mem, rs1 + imm));
define lw_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(32, loadWord_macro(mem, rs1 + imm)); 
define lbu_inst(rs1: bv32, imm: bv32):bv32 = bv_zero_extend(56, loadByte_macro(mem, rs1 + imm));
define lhu_inst(rs1: bv32, imm: bv32): bv32 = bv_zero_extend(48, loadHalf_macro(mem, rs1 + imm));
define addi_inst(rs1: bv32, imm: bv32): bv32 = rs1 + imm;
define slti_inst(rs1: bv32, imm: bv32):bv32 = bool_to_bv32[true -> 1bv32][false -> 0bv32][(rs1 < imm)]
define sltiu_inst(rs1: bv32, imm: bv32): bv32 = bool_to_bv32[true -> 1bv32][false -> 0bv32][(rs1 <_u imm)];
define xori_inst(rs1: bv32, imm: bv32): bv32 = (rs1 ^ imm);
define ori_inst(rs1: bv32, imm: bv32): bv32 = (rs1 | imm);
define andi_inst(rs1: bv32, imm bv32): bv32 = (rs1 & imm);
// SLLI: if !(imm <_u 64bv32) then exception == 2bv32 else return bv_left_shift(imm, rs1)
define slli_inst(rs1: bv32, imm: bv32): {bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][!(imm <_u 64bv32)], bv_left_shift(imm, rs1) };
// SRLI if !(imm <_u 64bv32) then exception  == 2bv32 else return bv_l_right_shift(imm,rs1)
define srli_inst(rs1: bv32, imm: bv32): {bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][!(imm <_u 64bv32)], bv_l_right_shift(imm, rs1) };
define srai_inst(rs1: bv32, imm: bv32): {bv32, bv32} = { bool_to_bv32[true -> 1bv32][false -> 0bv32][!(imm <_u 64bv32)], bv_a_right_shift(imm, rs1) };
// FIXME: Implement wfi instruction 
define wfi_inst(): bv32 = 0bv32;
define fence_inst(): bv32 = 0bv32;
define fence_i_inst(): bv32 = 0bv32;
define sfence_vma_inst(): bv32 = 0bv32;
define lwu_inst(rs1: bv32, imm: bv32): bv32 = bv_zero_extend(32, loadWord_macro(mem, rs1 + imm));
//define ld_inst(rs1: bv32, imm: bv32): bv32 = loadDouble_macro(mem, rs1 + imm);
// TODO: CHECK
//define addiw_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(32, (rs1[31:0] + imm[31:0])[31:0]);  
//define slliw_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(32, bv_left_shift((imm)[31:0], (rs1)[31:0]));
//define srliw_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(32, bv_l_right_shift((imm)[31:0], (rs1)[31:0]));
//define sraiw_inst(rs1: bv32, imm: bv32): bv32 = bv_sign_extend(32, bv_a_right_shift((imm)[31:0], (rs1)[31:0])); 
define sb_inst(rs1: bv32, imm: bv32, rs2: bv32): bv32 = mem_update_byte(mem, rs1 + imm, rs2[7:0]);
define sh_inst(rs1: bv32, imm: bv32, rs2: bv32): bv32 = mem_update_half(mem, rs1 + imm, rs2[15:0]);
define sw_inst(rs1: bv32, imm: bv32, rs2: bv32): bv32 = mem_update_word(mem, rs1 + imm, rs2[31:0]);
// define sd_inst(rs1: bv32, imm: bv32, rs2: bv32): bv32 = mem_update_double(mem, rs1 + imm, rs2);
define beq_inst(rs1: bv32, rs2: bv32, imm: bv32): bv32 = bool_to_bv32[true -> imm][false -> pc + 4bv32][rs1 == rs2];  
define bne_inst(rs1: bv32, rs2: bv32, imm: bv32): bv32 = bool_to_bv32[true -> imm][false -> pc + 4bv32][rs1 != rs2];
define blt_inst(rs1: bv32, rs2: bv32, imm: bv32): bv32 = bool_to_bv32[true -> imm][false -> pc + 4bv32][rs1 < rs2];
define bge_inst(rs1: bv32, rs2: bv32, imm: bv32): bv32 = bool_to_bv32[true -> imm][false -> pc + 4bv32][rs1 >= rs2]; 
define bltu_inst(rs1: bv32, rs2: bv32, imm: bv32): bv32 = bool_to_bv32[true -> imm][false -> pc + 4bv32][rs1 <_u rs2];  
define bgeu_inst(rs1: bv32, rs2: bv32, imm: bv32): bv32 = bool_to_bv32[true ->  imm][false -> pc + 4bv32][rs1 >=_u rs2];  
define lui_inst(imm: bv32): bv32 = bv_sign_extend(32, bv_left_shift(12bv32, 0bv12 ++ imm[19:0]));
define auipc_inst(imm: bv32): bv32 = (pc + bv_left_shift(12bv32, imm));
define jal_inst(imm: bv32): {bv32, bv32} = { pc + 4bv32 , pc = imm };
// INFO: returns exception, csr, rd
define csrrw_proc(csr: bv32, rs1: bv32): {bv32, bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][((current_priv <_u (csr)[9:8]) || ((0bv32 <_u rs1) && !(((csr)[11:10] <_u 3bv2))))], rs1, csr };
define csrrs_proc(csr: bv32, rs1: bv32): {bv32, bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][((current_priv <_u (csr)[9:8]) || ((0bv32 <_u rs1) && !(((csr)[11:10] <_u 3bv2))))], (rs1 | csr), csr };
define csrrc_proc(csr: bv32, rs1: bv32): {bv32, bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][((current_priv <_u (csr)[9:8]) || ((0bv32 <_u rs1) && !(((csr)[11:10] <_u 3bv2))))], (rs1 & csr), csr };
define csrrwi_proc(csr: bv32, imm: bv32): {bv32, bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][((current_priv <_u (csr)[9:8]) || (true && !(((csr)[11:10] <_u 3bv2))))], bv_zero_extend(59, imm[4:0]), csr };
define csrrsi_proc(csr: bv32, imm: bv32): {bv32, bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][((current_priv <_u (csr)[9:8]) || (true && !(((csr)[11:10] <_u 3bv2))))], (bv_zero_extend(59, imm[4:0]) | csr), csr }; 
define csrrci_proc(csr: bv32, imm: bv32): {bv32, bv32, bv32} = { bool_to_bv32[true -> 2bv32][false -> 0bv32][((current_priv <_u (csr)[9:8]) || (true && !(((csr)[11:10] <_u 3bv2))))], ((bv_zero_extend(59, imm[4:0])) & csr), csr };
